{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Canonical C++ Class With CAS","text":""},{"location":"#canonical-c-class","title":"Canonical C++ Class","text":"<p>For a c++ class that manages its own acquired resource (think memory or file  handles), the class should contain its own version of ctr, dtr, copy ctr and  copy assignment.  Since c++ 2010, this list includes move ctr and move  assignment.  This is all fine.  </p>"},{"location":"#noisy-copy-assignment","title":"Noisy copy assignment","text":"<p>One slight annoyance I noticed is that the the copy assignment operator  typical implementation of copy assignment is its usual book-keeping steps: 1) check if it's passed in itself for preventing self-copies,  2) clean up the source object's contained resource for preventing resource leaks and then 3) finally copying over the source object's resource. These steps to copy over a source object are a bit noisy to the eyes.</p>"},{"location":"#problem","title":"Problem","text":"<p>Perhaps we can do better with a copy-and-swap idiom for reducing this noise?  I gave this a try and immediately received a 'ambiguous overload' compiler error. The problem is this- the copy assignment's and move assignment's signatures are usually this:</p> <pre><code>Thing&amp; operator=(Thing&amp; other);     // copy assignment\nThing&amp; operator=(Thing&amp;&amp; other);    // move assignment\n</code></pre> <p>But when I make the copy assignment use copy-and-swap, this requires setting  its signature like this:</p> <pre><code>Thing&amp; operator=(Thing other);      // copy assignment\nThing&amp; operator=(Thing&amp;&amp; other);    // move assignment\n</code></pre> <p>This immediately confused the compiler because an rvalue could qualify for  both methods.  </p>"},{"location":"#solution","title":"Solution","text":"<p>The solution is to remove the move assignment implementation.  Both lvalues  and rvalues would work with the CAS-version of the copy assignment.</p> <p>Below is a sample implementation of a canoncial c++ class with CAS for its combined copy assignment and move assignment.  Runtime output is shown as well.</p> <pre><code>#include &lt;iostream&gt;\n\n// canonical class in c++\n//\n// default constructor (for arrays)\n// constructor - with parameter\n// destructor\n// copy constructor\n// copy assignment operator using CAS\n//\n// for c++11 and after\n// move constructor\n// move assignment operator\n\nstatic void log(const char *msg) { std::cout &lt;&lt; msg &lt;&lt; '\\n'; } // reduce noise\n\nclass Thing {\n    int* t; // just example, would never do this in production code\n\n public:\n    Thing()      : t(new int(0))    { log(\"ctr\"); }\n    Thing(int i) : t(new int(i))    { log(\"ctr_p\"); }\n    ~Thing()                        { delete t; log(\"dtr\"); };\n\n    // copy ctr\n    Thing(const Thing&amp; other) : t(new int(*other.t)) { log(\"copy ctr\"); }\n\n    // copy assignment using CAS, notice use of copy ctr in parameter\n    Thing&amp; operator=(Thing other)   {\n        std::swap(t, other.t);  // other was just created by copy ctr\n        log(\"copy assignment\");\n        return *this;\n    }\n\n    // move ctr\n    Thing(Thing&amp;&amp; other) noexcept :  // noexcept for optimisation\n        t(other.t) {        // steal the other's innards\n        other.t = nullptr;  // leave the other's blank\n        log(\"move ctr\");\n    }\n\n    // move assignment\n    // Thing&amp; operator=(Thing&amp;&amp; other) noexcept {\n    //      this fails compiling with a ambigious overload for\n    //      operator=, because rvalue fits for both the copy assignment\n    //      operator and the move assignment.\n    // }\n    //\n    // Thing&amp; operator=(Thing);   // Lead to ambiguous call\n    // Thing&amp; operator=(Thing&amp;&amp;); // Lead to ambiguous call\n    //\n    //  to fix- do this:\n    //  Thing&amp; operator=(Thing);\n    //\n    //  or\n    //  Thing&amp; operator=(const Thing&amp;);\n    //  Thing&amp; operator=(Thing&amp;&amp;);\n};\n\nThing get_thing() {\n    log(\"creating b\");\n    Thing b(2);\n    return b; \n}\n\nint main() {\n    log(\"creating a\");\n    Thing a(1);\n    log(\"returning b to a, overwrite a\");\n    a = get_thing();\n\n    log(\"creating c\");\n    Thing c(1);\n    log(\"copying c to a, overwrite a with copy assignment\");\n    a = c;\n}\n\n// output:\n// creating a\n// ctr_p\n// returning b to a, overwrite a\n// creating b\n// ctr_p\n// copy assignment\n// dtr\n// creating c\n// ctr_p\n// copying c to a, overwrite a with copy assignment\n// copy ctr\n// copy assignment\n// dtr\n// dtr\n// dtr\n</code></pre>"},{"location":"about/about/","title":"About ThinkCode","text":"<p>Learn, Record, and Reflect. </p> <p>This is the intent of ThinkCode.</p>"}]}