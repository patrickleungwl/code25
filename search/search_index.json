{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Canonical C++ Class With CAS","text":""},{"location":"#canonical-c-class","title":"Canonical C++ Class","text":"<p>For a c++ class that manages its own acquired resource (think memory or file  handles), the class should contain its own version of ctr, dtr, copy ctr and  copy assignment.  Since c++ 2010, this list includes move ctr and move  assignment.  This is all fine.  </p>"},{"location":"#noisy-copy-assignment","title":"Noisy copy assignment","text":"<p>One slight annoyance I noticed is that the the copy assignment operator  typical implementation of copy assignment is its usual book-keeping steps: 1) check if it's passed in itself for preventing self-copies,  2) clean up the source object's contained resource for preventing resource leaks and then 3) finally copying over the source object's resource. These steps to copy over a source object are a bit noisy to the eyes.</p>"},{"location":"#problem","title":"Problem","text":"<p>Perhaps we can do better with a copy-and-swap idiom for reducing this noise?  I gave this a try and immediately received a 'ambiguous overload' compiler error. The problem is this- the copy assignment's and move assignment's signatures are usually this:</p> <pre><code>Thing&amp; operator=(Thing&amp; other);     // copy assignment\nThing&amp; operator=(Thing&amp;&amp; other);    // move assignment\n</code></pre> <p>But when I make the copy assignment use copy-and-swap, this requires setting  its signature like this:</p> <pre><code>Thing&amp; operator=(Thing other);      // copy assignment\nThing&amp; operator=(Thing&amp;&amp; other);    // move assignment\n</code></pre> <p>This immediately confused the compiler because an rvalue could bind with both methods.  </p>"},{"location":"#solution","title":"Solution","text":"<p>One solution is to remove the move assignment implementation.  Both lvalues  and rvalues would work with the CAS-version of the copy assignment.</p> <p>Below is a sample implementation of a canoncial c++ class with CAS for its single copy assignment that works with both rvalues and lvalues.  The runtime  output is shown as well.</p> <pre><code>#include &lt;iostream&gt;\n\n// canonical class in c++\n//\n// default constructor (for arrays)\n// constructor - with parameter\n// destructor\n// copy constructor\n// copy assignment operator using CAS\n//\n// for c++11 and after\n// move constructor\n// move assignment operator\n\nstatic void log(const char *msg) { std::cout &lt;&lt; msg &lt;&lt; '\\n'; } // reduce noise\nstatic void log(char id, const char *msg) { std::cout &lt;&lt; ' ' &lt;&lt; msg &lt;&lt; ' ' &lt;&lt; id &lt;&lt; '\\n'; } // reduce noise\n\nclass Thing {\n    char* t; // just example, would never do this in production code\n            //\n\n public:\n    Thing()       : t(new char(' '))    { log(*t, \"ctr\"); }\n    Thing(char c) : t(new char(c))      { log(*t, \"ctr_p\"); }\n    ~Thing()                            { log(*t, \"dtr\"); delete t; };\n\n    // copy ctr\n    Thing(const Thing&amp; other) : t(new char(*other.t)) { log(*t, \"copy ctr\"); }\n\n    // copy assignment using CAS, notice use of copy ctr in parameter\n    Thing&amp; operator=(Thing other)   {\n        std::swap(t, other.t);  // other was just created by copy ctr\n        log(*t, \"copy assignment\");\n        return *this;\n    }\n\n    // move ctr\n    Thing(Thing&amp;&amp; other) noexcept :  // noexcept for optimisation\n        t(other.t) {        // steal the other's innards\n        other.t = nullptr;  // leave the other's blank\n        log(*t, \"move ctr\");\n    }\n\n    // move assignment\n    // Thing&amp; operator=(Thing&amp;&amp; other) noexcept {\n    //      this fails compiling with a ambigious overload for\n    //      operator=, because rvalue fits for both the copy assignment\n    //      operator and the move assignment.\n    // }\n    //\n    // Thing&amp; operator=(Thing);   // Lead to ambiguous call\n    // Thing&amp; operator=(Thing&amp;&amp;); // Lead to ambiguous call\n    //\n    //  to fix- do this:\n    //  Thing&amp; operator=(Thing);\n    //\n    //  or\n    //  Thing&amp; operator=(const Thing&amp;);\n    //  Thing&amp; operator=(Thing&amp;&amp;);\n};\n\nThing get_thing() {\n    log(\"creating b\");\n    Thing b('b');\n    return b; \n}\n\nint main() {\n    log(\"*** first test ***\");\n    log(\"creating a\");\n    Thing a('a');\n    log(\"returning b as a temporary rvalue to a, overwrite a with move assignment\");\n    a = get_thing();\n\n    log(\"*** second test ***\");\n    log(\"creating c\");\n    Thing c('c');\n    log(\"copying c as an lvalue to a, overwrite a with copy assignment\");\n    a = c;\n\n    log(\"end of test\");\n}\n</code></pre> <p>And the output:</p> <pre><code>*** first test ***\ncreating a\n ctr_p a\nreturning b as a temporary rvalue to a, overwrite a with move assignment\ncreating b\n ctr_p b\n copy assignment b\n dtr a\n*** second test ***\ncreating c\n ctr_p c\ncopying c as an lvalue to a, overwrite a with copy assignment\n copy ctr c\n copy assignment c\n dtr b\nend of test\n dtr c\n dtr c\n</code></pre>"},{"location":"about/about/","title":"About ThinkCode","text":"<p>Learn, Record, and Reflect. </p> <p>This is the intent of ThinkCode.</p>"}]}