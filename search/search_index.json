{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Canonical C++ Class With CAS","text":"<p>Let's discuss the issue in brief.</p>"},{"location":"#canonical-c-class","title":"Canonical C++ Class","text":"<p>For a c++ class that manages its own acquired resource (think memory or file  handles), the class should implement its own version of ctr, dtr, copy ctr and  copy assignment.  Since c++ 2010, this list includes move ctr and move  assignment.  This is all standard best practices.</p>"},{"location":"#noisy-copy-assignment","title":"Noisy copy assignment","text":"<p>One slight annoyance I noticed is that the the copy assignment operator  typical implementation of copy assignment is its usual book-keeping steps:</p> <ol> <li>check if it's passed in itself for preventing self-copies, </li> <li>clean up the source object's contained resource for preventing resource leaks and </li> <li>finally copying over the source object's resource.  </li> </ol> <p>These steps to copy over a source object are a bit tedious.  Is there another way?</p>"},{"location":"#problem","title":"Problem","text":"<p>Perhaps we can simplying the copy assignment by using a copy-and-swap pattern? I gave this a try and immediately received a 'ambiguous overload' compiler error. The problem is this- the copy assignment's and move assignment's signatures are usually this:</p> <pre><code>Thing&amp; operator=(Thing&amp; other);     // copy assignment\nThing&amp; operator=(Thing&amp;&amp; other);    // move assignment\n</code></pre> <p>But when I make the copy assignment use copy-and-swap, this requires setting  its signature like this:</p> <pre><code>Thing&amp; operator=(Thing other);      // copy assignment\nThing&amp; operator=(Thing&amp;&amp; other);    // move assignment\n</code></pre> <p>This immediately confused the compiler because an rvalue could bind with both methods.  </p>"},{"location":"#solution","title":"Solution","text":"<p>One solution is to remove the move assignment implementation.  Both lvalues  and rvalues would work with the CAS-version of the copy assignment.</p> <p>Below is a sample implementation of a canoncial c++ class with CAS for its single copy assignment that works with both rvalues and lvalues.  The runtime  output is shown as well.</p> <pre><code>#include &lt;iostream&gt;\n\n// canonical class in c++\n//\n// default constructor (for arrays)\n// constructor - with parameter\n// destructor\n// copy constructor\n// copy assignment operator using CAS\n//\n// for c++11 and after\n// move constructor\n// move assignment operator\n\nstatic void log(const char *msg) { std::cout &lt;&lt; msg &lt;&lt; '\\n'; } // reduce noise\nstatic void log(char id, const char *msg) { std::cout &lt;&lt; ' ' &lt;&lt; msg &lt;&lt; ' ' &lt;&lt; id &lt;&lt; '\\n'; } // reduce noise\n\nclass Thing {\n    char* t; // just example, would never do this in production code\n            //\n\n public:\n    Thing()       : t(new char(' '))    { log(*t, \"ctr\"); }\n    Thing(char c) : t(new char(c))      { log(*t, \"ctr_p\"); }\n    ~Thing()                            { log(*t, \"dtr\"); delete t; };\n\n    // copy ctr\n    Thing(const Thing&amp; other) : t(new char(*other.t)) { log(*t, \"copy ctr\"); }\n\n    // copy assignment using CAS, notice use of copy ctr in parameter\n    Thing&amp; operator=(Thing other)   {\n        std::swap(t, other.t);  // other was just created by copy ctr\n        log(*t, \"copy assignment\");\n        return *this;\n    }\n\n    // move ctr\n    Thing(Thing&amp;&amp; other) noexcept :  // noexcept for optimisation\n        t(other.t) {        // steal the other's innards\n        other.t = nullptr;  // leave the other's blank\n        log(*t, \"move ctr\");\n    }\n\n};\n\nThing get_thing() {\n    log(\"creating b\");\n    Thing b('b');\n    return b; \n}\n\nint main() {\n    log(\"*** first test ***\");\n    log(\"creating a\");\n    Thing a('a');\n    log(\"returning b as a temporary rvalue to a, overwrite a with move assignment\");\n    a = get_thing();\n\n    log(\"*** second test ***\");\n    log(\"creating c\");\n    Thing c('c');\n    log(\"copying c as an lvalue to a, overwrite a with copy assignment\");\n    a = c;\n\n    log(\"end of test\");\n}\n</code></pre> <p>And the output:</p> <pre><code>*** first test ***\ncreating a\n ctr_p a\nreturning b as a temporary rvalue to a, overwrite a with move assignment\ncreating b\n ctr_p b\n copy assignment b\n dtr a\n*** second test ***\ncreating c\n ctr_p c\ncopying c as an lvalue to a, overwrite a with copy assignment\n copy ctr c\n copy assignment c\n dtr b\nend of test\n dtr c\n dtr c\n</code></pre>"},{"location":"#discussion","title":"Discussion","text":"<p>What did the use of swap-and-copy accomplish for the copy assignment and  move assignment operations?  It</p> <ol> <li>reduces code redundancy, reuses the same code for both copy and move assignments</li> <li>simplifies the tiresome book-keeping assignment steps into one CAS step</li> </ol>"},{"location":"#code-details","title":"Code Details","text":"<p>The standard copy assignment and move assignment method signatures look like  this:</p> <pre><code>Thing&amp; operator=(const Thing&amp;); // copy assignment\nThing&amp; operator=(Thing&amp;&amp;);      // move assignment\n</code></pre> <p>When we replace the copy assignment with a copy-and-swap implementation, these signatures look like this:</p> <pre><code>Thing&amp; operator=(Thing);        // lead to ambiguous call\nThing&amp; operator=(Thing&amp;&amp;);      // lead to ambiguous call\n</code></pre> <p>The compiler immediately complains because an rvalue can bind to both methods. To fix this problem, we can go back to the original implementation OR ... simplify to one CAS-powered assignment which binds to both lvalues and rvalues:</p> <pre><code>Thing&amp; operator=(Thing);\n</code></pre>"},{"location":"#resource-leaks","title":"Resource leaks?","text":"<p>Valgrind did not report any resource leaks with the test code.</p> <p>Why did the rvalue returned by getValue() not produce an extra copy? These lines:</p> <pre><code>Thing a('a');       // create a\na = get_thing();    // create b and return b, overwriting a\n</code></pre> <p>only generated this output:</p> <pre><code>ctr_p a\nctr_p b\ncopy assignment b\ndtr a\n</code></pre> <p>Why did on the return of get_thing(), there was no additional copy created? Starting with c++ 17, the compiler is guaranteed to use return value optimization or RVO.  The compiler decides to allocate space in the stack for the return value- and the return value within the function is created in that space for return without the need to make an extra copy.  This eliminated one copy.</p> <p>Then the compiler binded the returned rvalue, a temporary value without a name,  to the copy assignment method- which, because of its value type argument,  works for both lvalues and rvalues. </p>"},{"location":"about/about/","title":"About ThinkCode","text":"<p>Learn, Record, and Reflect. </p> <p>This is the intent of ThinkCode.</p>"}]}